## Java基础

### 1.类加载简述

#### 1.1什么是类加载

类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。



#### 1.2什么时候启动类加载

JVM规范，允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或者存在错误，类加载器必须在程序首次使用该类时才报告错误，如果该类一直没有被程序主动使用，那类加载器就不会报告错误。



#### 1.3从哪个地方去加载.class文件

- 本地磁盘
- 网上加载.class（Applet）
- 从数据库中
- 压缩文件中
- 从其他文件生成的（JSP）
- 运行时，计算生成（动态代理）



#### 1.4类加载的过程

![类加载](/Users/yangzanjie/code/study/java面试整理/类加载.png)

1. **加载**

   **查找class字节码文件，装载入内存**

   - 从何处加载，看1.3。

   - 类加载器（后详述），一般包括：启动类加载器，扩展类加载器，应用类加载器，用户的自定义类加载器。

   

   **注：为什么会有自定义类加载器？**

   - java代码容易被反编译，可以对编译后的代码进行加密，通过自定义实现的类加载器解密，最后再加载。
   - 也可能从非标来源加载代码，此时需要自定义类加载器实现指定来源加载。

2. **验证**

   确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。

   包括：文件格式验证，元数据验证，字节码验证，符号引用验证。

3. **准备**

   为类变量（static修饰的）分配内存，并且赋予初值，使用的是方法区的内存，所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值（final修饰的类变量除外）。

   实例变量会在实例化时分配内存，在堆区。

   

4. **解析**

   将常量池的符号引用替换为直接应用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。得到它们在内存中的指针以便能直接访问。

   - 符号引用：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
   - 直接引用：可以理解为一个内存地址，或者一个偏移量。比如**类方法，类变量**的直接引用是指向方法区的**指针**；而**实例方法，实例变量**的直接引用则是从实例的头指针开始算起到这个实例变量位置的**偏移量**。

   举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

   在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。

   

5. **初始化**

   对类的静态变量，静态代码块执行初始化操作。

   

### 2.类加载器

实现类的加载动作，在JVM外部实现，以便应用程序自己决定如何加载。

**分类：**

- 启动类加载器，Bootstrap ClassLoader

  将存放于<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

- 扩展类加载器，Extension ClassLoader

  将<JAVA_HOME>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。

- 应用程序类加载器，Application ClassLoader

  负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。



### 3.类加载机制

- **全盘负责**

  当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

- **双亲委派**

  先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。优点：能确保一个类全局唯一，防止篡改的风险具有较高的安全性。

- **缓存机制**

  缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。



### 4.JVM内存模型

#### 4.1  基本结构

<img src="/Users/yangzanjie/code/study/java面试整理/JVM内存结构.png" alt="JVM内存结构" style="zoom:50%;" />

- **程序计数器**

  JVM规范中，线程私有。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。

- **本地方法栈**

  线程私有。为执行Native Method（Native Method就是一个java调用非java代码的接口）服务的。

- **Java虚拟机栈**

  线程私有，java方法执行的内存模型，生命周期与线程相同。

  其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。

  栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。

  局部变量表存放方法参数和方法内部的局部变量，该表的内存大小在java编译期间就分配好了，如果发生内存溢出则会抛出OutOfMemoryError 异常，当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；

- **堆**

  Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。

  划分为：新生代、老年代、From Survivor、To Survivor；

- **方法区**

  所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。

  **运行时常量池**

  Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用。

- **直接内存（Direct Memory）**

  规范不涉及。Direct Buffer 所直接分配的内存，易出问题。

- **其他内存**

  JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，但规范中并不涉及。



#### **4.2 详解堆内存结构**

<img src="/Users/yangzanjie/code/study/java面试整理/堆内存结构.png" alt="堆内存结构" style="zoom:50%;" />

1. **新生代**

   新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。

2. **老年代**

   放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。

3. **永久代**

   早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。



### 5.垃圾收集（GC，Garbage Collector）

#### 5.1 对象实例收集

目的：清楚哪些内存可以被释放。

两种基本算法：

- **引用计数法**

  为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。

  Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

- **（Java用这个）可达性分析法**

  将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots。

**注：方法区无用元数据的回收比较复杂。**

一般来说初始化类加载器加载的类型是不会进行类卸载（unload）的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会 OOM。



#### 5.2 垃圾收集算法

##### **5.2.1 总结**

- Serial收集器：串行运行；作用于新生代；复制算法；响应速度优先；适用于单CPU环境下的client模式。
- ParNew收集器：并行运行；作用于新生代；复制算法；响应速度优先；多CPU环境Server模式下与CMS配合使用。
- Parallel Scavenge收集器：并行运行；作用于新生代；复制算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。
- Serial Old收集器：串行运行；作用于老年代；标记-整理算法；响应速度优先；单CPU环境下的Client模式。
- Parallel Old收集器：并行运行；作用于老年代；标记-整理算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。
- CMS收集器：并发运行；作用于老年代；标记-清除算法；响应速度优先；适用于互联网或B/S业务。
- G1收集器：并发运行；可作用于新生代或老年代；标记-整理算法+复制算法；响应速度优先；面向服务端应用。

##### **5.2.2 详细**

- 复制

  新生代 GC，基本都是基于复制算法，将活着的对象复制到 to 区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。

  默认，Eden和两个Survivor的大小比例为8:1:1。每次都是把Eden和Survivor中存活的对象拷贝到另一块Survivor中。

  优点是避免了产生内存碎片等情况。缺点是浪费了一部分内存。（既然要进行复制，既要提前预留内存空间，有一定的浪费）。另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。

- 标记-清除

  首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现 Full GC，暂停时间可能根本无法接受。

- 标记-整理

  类似于标记 - 清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。

- 分代收集

  是目前大多数虚拟机采用的垃圾回收算法。Java堆分为新生代和老年代，新生代选用复制算法，而老年代使用“标记-清理”或“标记-整理”算法来进行回收。



#### 5.3 垃圾收集器

1. **Serial 收集器 (新生代)**

   单线程的收集器，当该收集器运行时必须暂停其他所有的工作线程，直到它收集结束。
   算法：复制算法
   优点：简单高效，拥有很高的单线程收集效率
   应用：Client模式下的默认新生代收集器，桌面应用内存一般不大，几十毫秒的停顿时间可以接受。

2. **ParNew 收集器 (新生代)**

   Serial 的多线程版本，原理与Serial 收集器一致，若老年代使用CMS收集器，则新生代只能使用ParNew 收集器（或者Serial收集器）

3. **Parallel Scavenge 收集器(新生代)**

   与ParNew 一样使用复制算法，多线程收集器，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，高吞吐量可以最高效的利用CPU时间
   吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
   控制吞吐量的参数：最大垃圾收集停顿时间 -XX：MaxGCPauseMillis ; 直接设置吞吐量大小：-XX:GCTimeRatio。
   MaxGCPauseMillis 的值为一个大于0的毫秒数， 最大停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的。
   GCTimeRatio 的值为一个大于0且小于100的整数。例如：-XX:GCTimeRatio=19，允许最大的GC时间为5%(1/(1+19))，默认值为99。
   -XX:+UseAdaptiveSizePolicy:开启GC自适应调节策略，自动设置新生代大小、Eden与Survior区的比例、晋升老年代对象年龄等细节参数。

4. **Serial Old 收集器 (老年代)**

   Serial收集器的老年代版本，也是一个单线程的收集器，使用标记-整理算法

5. **Parallel Old 收集器 (老年代)**

   Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。与Parallel Scavenge收集器配合使用，吞吐量优先。

6. **CMS(concurrent mark sweep) 收集器 (老年代)**

   以获取最短回收停顿时间为目标，基于“标记-清除”算法。
   缺点：
   1)对cpu资源敏感，默认启动的回收线程数是（cpu数量+3）/4，当cpu数较少的时候，会分掉大部分的cpu去执行收集器线程，影响用户，降低吞吐量。
   2)无法处理浮动垃圾，浮动垃圾即在并发清除阶段因为是并发执行，还会产生垃圾，这一部分垃圾即为浮动垃圾，要等下次收集。
   3)因为使用的是“标记-清除”算法，会产生碎片。

7. **G1(garbage first)收集器 (整个Java堆：包括新生代和老年代)**

   基于标记-整理算法，不会产生空间碎片，并且可以精确的控制停顿时间。G1将整个堆划分为多个固定的独立区域，在后台维护一个优先级列表，每次根据允许的时间范围，优先收回垃圾最多的区域。

8. **JVM垃圾收集器相关常用参数：**

   <img src="/Users/yangzanjie/code/study/java面试整理/JVM垃圾收集器相关常用参数.png" alt="JVM垃圾收集器相关常用参数" style="zoom:80%;" />

9.**GC新发展**

GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如， JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。

即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。

比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。



### 6. Java性能调优工具

1. jps

   虚拟机进程状况工具。

   ```markdown
   参数：
   -m 输出虚拟机启动时传递给主类main()函数的参数
   -l 输出主类全名，如果进程执行的是jar包，输出jar路径
   -v 输出虚拟机进程启动时JVM参数
   ```

2. jstat

   虚拟机统计信息监视工具

   ```
   格式：jstat [option] pid [interval] [count]
   ->jstat -gc [pid] 500 20
   表示监视Java堆状况，每500毫秒查询一次，共查询20次
   ```

   <img src="/Users/yangzanjie/code/study/java面试整理/jstat 虚拟机统计信息监视工具 参数详细.png" alt="jstat 虚拟机统计信息监视工具 参数详细" style="zoom:80%;" />

3. jmap

   java内存映像工具

   ```markdown
   格式：jmap [ option ] pid
   参数：
   -dump:[live,]format=b,file= 使用hprof二进制形式,输出jvm的heap内容到文件， live子选项是可选的，假如指定live选项，那么只输出活的对象到文件。
   -finalizerinfo 打印正等候回收的对象的信息。
   -heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况。
   -histo[:live] 打印每个class的实例数目，内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”。 如果live子参数加上后，只统计活的对象数量。
   -permstat 打印classloader和jvm heap永久代的信息。
   -F 在虚拟机进程对-dump没有响应时，强制生成dump快照。 在这个模式下,live子参数无效。
   ```

4. jstack

   java线程堆栈跟踪工具

   ```markdown
   格式：jstack [ option ] pid
   参数： 
   -F 正常输出请求不响应时，强制输出线程堆栈
   -l 显示关于锁的附加信息
   -m 如果调用本地方法，可以显示C/C++的堆栈
   ```

   

### 7. 并发

#### 7.1 创建线程

创建线程的三种方式：

1. 继承Thread，重写run()方法，创建实现类示例并调用start()方法；
2. 实现Runnable接口，重写run()方法，实现类作为Thread(Runnable target)的入参；
3. 实现Callable接口，重写call()方法，实现类作为FutureTask(Callable callable)的入参；

#### 7.2 线程池

Spring中的ThreadPoolTaskExecutor，完全是使用ThreadPoolExecutor进行实现，是对ThreadPoolExecutor的增强。

```xml
<!-- 异步线程池 -->
<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <!-- 核心线程数，默认为1 -->
    <property name="corePoolSize" value="3"/>
    <!-- 最大线程数，默认为Integer.Max_value -->
    <property name="maxPoolSize" value="10"/>
    <!-- 队列最大长度，默认为Integer.Max_value -->
    <property name="queueCapacity" value="25"/>
    <!-- 线程池维护线程所允许的空闲时间，默认值60s -->
    <property name="keepAliveSeconds" value="300"/>
    <!-- 设置为true（默认false）时，corePoolSize核心线程会超时关闭 -->
    <property name="allowCoreThreadTimeOut" value="true"/>
    <!-- 线程池对拒绝任务(无线程可用)的处理策略，默认策略 AbortPolicy  -->
    <property name="rejectedExecutionHandler">
        <!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 -->
        <!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 -->
        <!-- DiscardOldestPolicy:抛弃旧的任务；会导致被丢弃的任务无法再次被执行 -->
        <!-- DiscardPolicy:抛弃当前任务；会导致被丢弃的任务无法再次被执行 -->
        <bean class="java.util.concurrent.ThreadPoolExecutor.DiscardPolicy"/>
    </property>
</bean>
```



### 8. 锁

#### 8.1 基本的锁

<img src="/Users/yangzanjie/code/study/java面试整理/Java Lock类关系.png" alt="Java Lock类关系" style="zoom:50%;" />

- 读写锁(ReadWriteLock)：ReadWriteLock将锁拆分为读锁和写锁，读锁可以并发获取。
- 可重入锁(ReentrantLock,ReentrantReadWriteLock)：锁具备可重入性，同一线程可以多次获得锁，不同线程获得锁则需要等待。
- 乐观锁/悲观锁：乐观锁取数据的时候不会上锁，更新数据的时候或判断期间是否有人已经更新了数据，可以使用版本号之类的机制来保证；悲观锁取数据的时候就马上上锁，知道处理结束，数据库行锁、表锁、synchronized关键字使用的都是悲观锁。
- 公平锁/非公平锁：公平锁保证等待时间最长的线程将优先获得锁，而非公平锁并不会保证多个线程获得锁的顺序，但是非公平锁的并发性能表现更好。
- 自旋锁：非阻塞锁，A线程要获取的锁被其它线程占用，线程A不会马上被挂起，而是执行空循环，不停的试图获取锁。执行空循环属于用户态，被挂起属于内核态，这样可以避免用户态和内核态之间互相切换引起的开销和损耗。

#### 8.2  分布式锁

分布式锁的三种实现方式：https://www.jianshu.com/p/8bddd381de06

zookeeper与redis的比较：https://zhuanlan.zhihu.com/p/73807097  

- zookeeper分布式锁：
  参考文档：https://blog.csdn.net/crazymakercircle/article/details/85956246

- Redis分布式锁：
  基于setnx（set if not exists）命令实现。
  setnx格式：SETNX key value
  将 key 的值设为 value ，当且仅当 key 不存在。
  若给定的 key 已经存在，则 SETNX 不做任何动作。
  缺点：Redis肌群如果某个master服务器宕机，slave服务器替换master服务器期间，由于master服务器到slave服务器之间的数据同步是异步的，可能会有短暂时间的数据丢失，会导致重复加锁。

#### 8.3 ThreadLocal

参考：Q4:关于强引用、软引用、弱引用、虚幻引用

#### 8.4 Condition

基本方法是await(),signal()，可用于替代Object的wait()，notify()方法，实现线程间的协作。两者都要先获得锁之后才可调用，不同的是Object的wait(),notify()对应的是synchronized方式的锁，Condition对应的是实现Lock接口的锁。

#### 8.5 死锁

- 合理安排锁的顺序，避免死锁
- 尽量使用定时锁（lock.tryLock(timeout)）
- 尽量避免锁嵌套，减少锁持有的时间，减小锁的粒度

#### 8.6 性能

- 减小锁的范围（锁的代码块尽可能小）；
- 减小锁的粒度；
  例如：将锁分拆到用户的维度，不同用户之间锁的分离的；使用ConcurrentHashMap，ReadWritLock等分离锁的粒度，减少冲突的可能性；
- 启用适当的线程数，减少线程切换的消耗；

#### 8.7 同步工具类

- CountDownLatch：可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，就可以利用CountDownLatch来实现。
- CyclicBarrier：可以实现让一组线程等待至某个状态之后再全部同时执行。
- Semaphore：可以控同时访问的线程个数，Semaphore(int permits)初始化最多可以有几个线程能同时访问，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。

#### 8.8 Atomic

- atomic包中的类是基于CAS（比较与交换，Compare and swap）原理实现的。

- CAS：CPU指令，在大多数处理器架构都支持的CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是乐观锁 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

- CAS与lock的区别：

  lock采用的是悲观锁，需要线程间的上下文切换；
  CAS由底层硬件直接支持，采用乐观锁，自旋等待，不需要线程上下文切换；在高并发下CPU资源消耗较大；



### 9.  IO

- bio:同步阻塞I/O，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的场景，这种方式对服务端资源要求比较高，并发局限于应用中。


- nio:同步非阻塞I/O，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的场景。Channel(通道)，Buffer(缓冲区), Selector(选择器)。


- aio:异步非阻塞I/O，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的场景，充分调用OS参与并发操作。



### 10. Annotation

Annotation其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，通常与AOP、反射一起使用，在动态代理中识别有特殊注解标记的类或方法，并执行相应的处理。
注解的继承：
1.用在类上的自定义注解可以被继承下来。作用在接口上自定义注解不能被实现它的类继承下来。
2.类或接口方法上的自定义注解不能被重写或实现了其方法的子类继承。例如：A是接口，C类实现了A接口，但A接口方法上的注解无法被C类实现的方法继承；B是方法带注解的类，C继承了B类，C类如果重写了B的方法，B方法原有的注解是无法继承的，C如果没有重写B的方法，则可以继承B类方法原有的注解。



### 11. 动态代理

JDK动态代理/CGlib代理：
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。JDK使用Proxy和InvocationHandler实现代理
CGLIB是针对类实现代理，继承指定的类生成一个子类，覆盖其中的方法以实现增强，所以该类或方法不能声明成final，final类或方法是无法继承的。
spring如何实现动态代理：当Bean实现接口时，Spring会用JDK动态代理。当Bean没有实现接口时，Spring会使用CGlib实现动态代理。CGlib使用Enhancer和MethodInterceptor实现代理。可以通过配置：<aop:aspectj-autoproxy proxy-target-class=“true”/>强制限制spring使用CGlib代理。



