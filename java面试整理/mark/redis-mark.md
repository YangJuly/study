1.缓存使用的优缺点

```
优点：
高性能
高并发

缺点：
缓存与数据库双写不一致
缓存雪崩
缓存穿透
缓存并发竞争
```

2.redis线程模型

```
redis对比memcached
	-redis支持服务端的数据操作
	-redis拥有更丰富的数据结构和数据操作
	-redis原生支持集群模式
```

```
redis线程模型
	-redis的文件事件处理器，单线程，io多路复用监听多个socket，实现高性能。
	-文件事件：socket可读，socket可写，优先处理读
	-略
```

```
为啥单线程效率如此高？
	-纯内存操作
	-核心基于非阻塞io多路复用机制
	-单线程避免了多线程下的上下文切换
```

3.redis的数据类型

```
1.string
2.list      
3.hash
4.set
5.sortedset
```

4.redis过期策略

```
1.设置过期时间
		-定期删除：定期随机删除过期
		-惰性删除：访问时，是否过期。
2.内存淘汰
	如果内存占用过高，会进行内存淘汰
	 - 内存不足，新写数据报错
	 - 移除最近最少使用数据
	 - 随机删除某数据
	 - 在设置过期时间的数据中，随机移除
	 - 在更早过期事件的数据，先删除
```

5.redis高并发高可用

```
redis性能瓶颈在单机
主从架构 
哨兵架构
集群
```

```
集群
	-支撑多个master node，每个master node挂在多个slave node
	-读写分离，写->master，读从slave读。
	-高可用，master挂掉，自动将某个slave切换成master
```

```
redis集群节点通信
	-gossip协议，非集中式，互相之间不断通信。
			-集中式，好处在于，元数据的读取和更新，时效性好，但更新压力集中，有压力
			-gossip，数据分散，更新请求陆陆续续，降低压力，但会滞后
```

```
高可用和主备切换原理
	-判断宕机
			-主关宕机
			-客观宕机
	-从节点过滤
			-检查断开连接的时间
	-从节点选举
			-根据对主节点复制数据的offset，来设置选举
```

6.缓存雪崩、缓存穿透

```
雪崩
	-事前   高可用，主从、哨兵、集群，避免全盘崩溃 
	-事中    本地ehcache缓存+hystrix限流&降
	-事后    持久化，快速恢复
```

```
穿透
	-现象：每次查空值，将请求落到数据库
	-保存空值
	-或者用布隆过滤器
```

7.双写一致性

```
缓存+数据库读写的模式
	（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应
	（2）更新的时候，先删除缓存，然后再更新数据库
```

```
数据库与缓存更新与读取操作进行异步串行化

更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中

读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中
	
一个队列对应一个工作线程

每个工作线程串行拿到对应的操作，然后一条一条的执行

这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新

此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成

这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可

待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值
```

```
由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回

该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库

做一些压力测试
```

8.并发竞争问题

```
某个时刻多个系统实例要去更新某个key

-用分布式锁，确保同一时间，只有一个实例操作
-每次写之前，通过时间戳判断，更新可以写，如果更久则不能
```