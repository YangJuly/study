# Java面试整理

### Q1： 对Java平台理解

Java，一种面向对象的编程语言。

最显著的特性体现在两个方面：

1. 跨平台能力，Write once, run anywhere. 
2. 垃圾收集，garbage collection - GC. Java通过GC回收分配的内存。

日常接受到的JRE和JDK，

1. JRE，Java runtime environment，Java运行环境，包含了jvm和Java类库，以及一些模块等。
2. JDK，Java Development Kit，可以看做是JRE的一个超集，提供了更多的工具，包括编译器、各种诊断工具等。

关于Java代码的运行，三个阶段：编码--编译--运行--调试。

javac将源代码转化成.class文件字节码，这是第一次编译，.class文件就是可以到处运行的文件在运行时，java字节码会被jvm中的解释器转换成最终的机器码。常见的Jvm，例如Oracle JDK的JVM，提供了JIT编译器，动态编译，能在运行时将热点代码编译成机器码，此时这部分代码就是编译执行，而不是解释执行。

Java平台图：

![java平台](/Users/yangzanjie/code/study/java面试整理/java平台.png)



### Q2：Exception和Error？

Java中，Exception和Error都继承自Throwable类，只有Throwable类型的实例才可以被Throw或者catch，是异常处理机制的基本组成类型。

Error是指不可预料的异常情况，会导致程序处于非正常、不可恢复的状态，比如OutOfMemoryError。

Exception和Error体现了Java平台设计者对不同异常情况的分类。Exception是正常运行时，可以预料的异常情况，可能并且应该被捕获，进行相应处理。

Exception分为可检查异常和不可检查异常。可检查异常在源代码中，必须显示的捕获处理，是编译检查的一部分。

不可检查异常即运行时异常，例如NullPointerException、ArrayIndexOutOfBoundsException，不会在编译期强制要求。

- 常见的Error和Exception：

![常见的Error和Exception](/Users/yangzanjie/code/study/java面试整理/常见的Error和Exception.png)

- 基本语法：

  try-catch-finally（try-with-resources，multiple catch），throw，throws等。



实践中的经验：

1. 尽量不要捕获类似Exception这种通用异常，应该捕获特定异常。
2. 不要生吞异常。
3. catch异常后，标准输出不一定是最好选项，要记录堆栈信息，同时，在保证诊断信息充足的同时，要避免泄露信息，比如机器名、机器IP、端口等。
4. Throw early, catch late原则。否则堆栈信息容易让人费解。
5. 关于Checked的争论：try-catch带来的性能损耗，不兼容函数式编程，大部分的异常捕获后，其实恢复不了程序。



扩展：

NoClassDefFoundError与ClassNotFoundException的区别：

NoClassDefFoundError是Error，发生在运行期，产生原因，在编译期能找到类，在运行期招不到类，可能是打包过程中漏掉或者删掉了该类，也可能jar包损坏或者被篡改。

ClassNotFoundException是Exception，Java支持反射在运行时动态加载类，例如Class.forName方式动态加载类时，若类未找到，就会出现该异常。



### Q3：final、finally、finalize的区别？

1. final

   修饰类：不可被继承

   修饰方法：不可被重写

   修饰变量：不可修改，只能约束引用不可被再次赋值。

2. finally

   java保证重点代码一定执行的机制，try-finally，除非在finally前执行了system.exit(1)、try中死循环、线程被杀死。

3. finalize

   基础类Object的一个方法，保证对象在被垃圾收集前完成特定资源的回收。由于finalize执行时间不确定且可能造成线程死锁、拖慢垃圾收集等问题，java9中已将该方法废弃。

   优化：使用Cleaner配合幻想引用。



关于性能:

- 将类和方法声明为final，明确告诉使用者，不可被修改。避免api使用者更改基础功能，保证平台安全。
- 使用final修饰参数或者变量，可避免意外赋值导致的错误。
- final变量，可用于保护只读数据，同时在并发编程中，由于不可修改，可以减少额外的同步开销，可以省去一些防御性拷贝的必要。
- final有助于方法内联，改善编译器进行条件编译的能力。



java目前没有原生immutable的类，要实现，需要做到：

- 将class声明为final，
- 将所有成员变量定义为private和final，不要事先setter方法，
- 成员变量的赋值，使用深度拷贝来初始化，
- 如果确实要实现getter方法，使用copy-on-write原则，创建私有的copy



### Q4:关于强引用、软引用、弱引用、虚幻引用

主要体现对象不同的可达性状态和对GC的影响。

- 强引用

  典型编码，通过关键字new创建的对象所关联的引用就是强引用。当JVM内存不足时，JVM宁愿抛出oom，程序终止，也不会靠随意回收具有强引用的存活对象来解决oom。

  若要回收强引用，赋值为null，具体何时回收需要看gc策略。

- 软引用

  通过SoftReference类实现。软引用的生命周期比强引用短一些，只有当JVM内存不足的时候，才会去试图回收软引用指向的对象。

  软引用可以和一个引用队列ReferenceQueue联合使用，如果被回收，jvm将这个软引用加入到队列中，后续可以用ReferenceQueue的poll方法检查是否有关心的对象被回收，若队列为空，则为null，否则返回队列中前面一个对象。

  应用场景：通常用来实现敏感缓存。如果有空闲内存，暂时保留缓存，当内存不足时，清理掉，保证使用缓存的同时，内存不会耗尽。

- 弱引用

  通过WeakReference类实现。生命周期比软引用短。在GC线程扫描它所管辖的内存区域时，一旦发现了弱引用的对象，不管当前内存是否充足，都会回收对象的内存。同样可以和引用队列ReferenceQueue联合使用。

  应用场景：同样可以用于内存敏感的缓存。

- 虚引用

  通过PhantomReference类实现。无法通过虚幻引用访问对象的任何属性和函数。仅提供了一种确保对象被finalize后做某些事的机制。如果一个对象仅持有虚幻引用，那么就和没有任何引用一样，在任何时候都可能被gc。同样可和引用队列联合。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。

  应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。



### Q5:理解String、StringBuilder、StringBuffer。

1. String 特性

   为了避免在一个系统中产生大量的String对象，引入了字符串常量池。

   创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建，直接从池中刚查找到的对象的引用；如果没有则新建字符串对象，返回对象引用，并将新创建的字符串对象放入池中。但是，通过new方法创建的String对象是不检查字符串常量池的，直接在堆区或栈区创建一个新的对象，也不会将对象放入池中。

   举例：String str1 = "123"; //通过直接量赋值方式，放入字符串常量池
   String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池

   注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。

   - 不可变：String对象一旦生成，则不能对它进行修改。不可变主要作用，提高多线程的性能。
   - 针对常量池的优化：当同一个字符串反复出现时，大幅节省内存空间。

2. StringBuffer和StringBuilder

   - 相同：

     两者都实现了AbtractStringBuilder抽象类，拥有几乎一致的对外提供的调用接口。底层在内寸中的存储方式与String相同。不同点是StringBuffer/StringBuilder对象的值可以改变，且值改变后，对象引用不变。

     两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。

   - 不同：

     StringBuffer是线程安全的，方法定义前面都有synchronize关键字。

     StringBuilder不是线程安全的。

     

### Q6:谈谈Java的反射机制，动态代理基于什么原理？

1. 关于反射

   最大作用，可以不在编译时知道某个对象的类型，而在运行时通过提供完整的"包名+类名.class"得到。

   功能：

   - 在运行时，判断任意一个对象所属的类。
   - 在运行时，构造任意一个类的对象。
   - 在运行时，判断任意一个类具有的成员变量和方法。
   - 在运行时，调用任意一个对象的方法。

   大白话：利用Java反射机制我们可以加载一个运行时才得知名称的class，获悉其构造方法，并生成其对象实体，能对其fields设值并调用起其methods。

   应用场景：

   通常在各类通用框架开发中。为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就用到反射，----运行时动态加载需要加载的对象。

   特点：

   反射会消耗一定的系统资源，因此，不需要用反射，尽量不要用。另外，反射调用方法时，可以忽略权限检查，可能会破坏封装性，导致安全问题。

2. 关于动态代理

   为其他对象提供一种代理以控制这个对象的访问。静态代理/动态代理。

   静态代理，自己写代理类。

   动态代理，实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。

   （动态）组成要素：

   - 抽象类接口
   - 被代理类：具体实现抽象接口的类
   - 动态代理类：实际调用被代理类的方法和属性的类

   实现方式：

   1. JDK自带的动态代理类，主要利用反射机制。
   2. 比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等。

   

   **Spring AOP支持两种模式的动态代理，JDK Proxy或者CGLIB**。

   JDK Proxy劣势，以接口为纽带，依赖于接口，从api设计和实现的角度有局限。

   CGLIB动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。

   比较JDK和CGLIB：

   JDK Proxy优势：

   - 最小化依赖关系，减少依赖意味简化开发和维护，此外相较于cglib，jdk本身可能更可靠
   - 平滑进行jdk升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
   - 代码实现简单。

   CGLIB优势：

   - 有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。
   - 只操作我们关心的类，而不必为其他相关类增加工作量。
   - 高性能。

   AOP，简单来说它可以看作是对 OOP 的一个补充，因为 OOP 对于跨越不同对象或类的分散、纠缠逻辑表现力不够，比如在不同模块的特定阶段做一些事情，类似日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。

   

   

### Q7:谈谈int和Integer的区别？

int是整型数字，是java的8个原始数据类型（boolean,byte,short,int,long,double,float,char）之一。

Integer是int对应的包装类，有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间的转换等。java可以根据上下文，自动进行装箱/拆箱。

关于Integer值缓存，构建Integer对象，传统new，但是大部分操作集中在数值较小的范围，静态工厂方法valueOf，调用的时候，利用了一个缓存机制，默认在-128到127之间。

1. 理解自动装箱/拆箱

   一种语法糖。发生在编译期。

   javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()。

   原则上，避免无意中的装箱、拆箱行为。

2. 线程安全

   - 建议考虑使用类似 AtomicInteger、AtomicLong 这样的线程安全类
   - 部分较宽的数据，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！

3. 原始数据类型和引用类型局限

   - 原始数据类型和Java泛型不能适配

   - 无法高效地表达数据，也不便于表达复杂的数据结构，例如vector、tuple等

     原始数据类型的数组，在内存中是一段连续的内存，而对象数组则不然，存储的是引用。无法充分利用现代cpu的缓存机制。

     Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。

对象：

对象由三部分组成，对象头，对象实例，对齐填充。

对象头一般是十六个字节，包括两部分，第一部分有哈希码，锁状态标志，线程持有的锁，偏向线程id，gc分代年龄等。第二部分是类型指针，也就是对象指向它的类元数据指针，可以理解，对象指向它的类。

对象实例就是对象存储的真正有效信息，也是程序中定义各种类型的字段包括父类继承的和子类定义的，这部分的存储顺序会被虚拟机和代码中定义的顺序影响。

第三部分对齐填充只是一个类似占位符的作用，因为内存的使用都会被填充为八字节的倍数。



### Q8: 对比Vector、ArrayList、LinkedList的区别

均为线型的数据结构。

1. 底层实现方式

   ArrayList内部用数组来实现，LinkedList内部用双向链表实现，Vector内部用数组实现。

2. 读写机制

   ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。

   LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。

   Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有的1.5倍；如果capacityIncrement<=0,则将Object数组的大小扩大为现有大小的2倍。

3. 读写效率

   ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。

   LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。

4. 线程安全性

   ArrayList、LinkedList为非线程安全；Vector是基于synchronized实现的线程安全的ArrayList。

   需要注意的是：单线程应尽量使用ArrayList，Vector因为同步会有性能损耗；即使在多线程环境下，我们可以利用Collections这个类中为我们提供的synchronizedList(List list)方法返回一个线程安全的同步列表对象。



Set：

- TreeSet （默认利用TreeMap实现）支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n) 时间）。
- HashSet 则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。
- LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于 HashSet，因为需要维护链表的开销。
- 在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。



Java 提供的默认排序算法：（Arrays.sort() 还是 Collections.sort()）

- 对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序。
- 而对于对象数据类型，目前则是使用TimSort，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。

Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架（专栏后面会对 fork-join 进行相对详细的介绍），当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。



### Q9：对比HashTable、HashMap、TreeMap的区别？

都是常见的一些Map实现，以键值对的形式存储和操作数据的容器类型。

HashTable是早期Java类库提供的一个哈希表实现，是同步的，不支持null键和值，由于同步导致的性能开销，已经很少被推荐使用。

HashMap应用更加广泛的哈希表实现，行为上大致与HashTable一致，主要区别在于HashMap不是同步的，支持null值和键。通常情况下，HashMap进行put和get，可以达到常数的性能。

TreeMap是基于红黑树的一种提供顺序访问的Map，它的get、put、remove之类操作都是O(logn)的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。



**HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定：**

务必要重写hashcode和equasl方法。

- equals相等，hashCode也要相等
- 重写hashCode也要重写equals
- hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致
- equals 的对称、反射、传递等特性

**HashMap树化**：安全问题，当大量哈希冲突时，会形成一个链表，链表查询是线性的，影响性能。



### Q10: 如何保证集合的线程安全？ConcurrentHashMap如何高效实现线程的安全？

略



### Q11: Java提供了哪些IO方式？NIO如何实现多路复用。

- BIO

  同步阻塞IO。

  首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。

  java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。

- NIO

  在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

- AIO

  在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。



区分同步或异步（synchronous/asynchronous）

简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。



区分阻塞与非阻塞（blocking/non-blocking）

在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。



**注意的几点：**

- IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。
- 输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。
- Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。
- BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。
- 很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（FileDescriptor），需要利用 try-with-resources、 try-finally 等机制保证 FileInputStream 被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放

![java-io](/Users/yangzanjie/code/study/java面试整理/java-io.png)



**NIO概览--主要组成部分：**

- Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。
- Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。
- Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。





### Q12: Java有几种文件拷贝方式，哪种最高效？

几种文件拷贝方式：

- java.io库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。
- java.nio库，提供的 transferTo 或 transferFrom 方法实现。
- java标准类库，提供了几种 Files.copy 的实现。

NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。



扩展：

- 拷贝机制分析

  用户态空间、内核态空间

  当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。

  而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。

- 略



### Q13：谈谈接口和抽象类的区别？

- 接口，是对行为的抽象，是抽象方法的集合，利用接口可以达到定义和实现分离的目的。

  接口不能实例化，不能包含任何非常量成员，任何field都隐含着public static final的意义，同时，没有非静态方法实现。

  实现 interface 使用 implements 关键词。

- 抽象类，是不能实例化的类，用abstract修饰class，主要目的是为了代码重用。

  可以有一个或多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。

  继承 abstract class 则是使用 extends 关键词。



**面向对象设计**：

- 封装
  What：隐藏信息，保护数据访问。
  How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
  Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

- 抽象
  What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
  How: 通过接口类或者抽象类实现，特殊语法机制非必须。
  Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

- 继承
  What: 表示 is-a 关系，分为单继承和多继承。
  How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
  Why: 解决代码复用问题。

- 多态
  What: 子类替换父类，在运行时调用子类的实现。
  How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
  Why: 提高代码扩展性和复用性。



**SOLID原则：**

- 单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。

- 开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。

- 里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。

- 接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。

  对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。

- 依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。



### Q14：谈谈你知道的设计模式？

手动实现单例模式？Spring框架中用了哪些模式？



- 创建型模式

  对对象创建过程的各种问题和解决方案的总结。包括各种工厂模式、单例模式、构建器模式、原型模式。

- 结构型模式

  针对软件设计结构的总结，关注类、对象继承、组合方式的实践经验。

  桥接模式、适配器模式、装饰者模式、代理模式、组合模式、外观模式、享元模式等。

- 行为型模式

  从类或对象之间交互、职责划分等角度总结的模式。

  策略模式、解释器模式、命令模式、观察者模式、迭代器模式、模板方法模式、访问者模式。



**单例模式**：https://www.jianshu.com/p/5cc98ce4a82a

- 保证一个类只有一个实例，且整个系统都能访问该实例

**工厂模式**：https://www.jianshu.com/p/5305eab7b93b

- 抽象工厂角色，具体工厂角色，抽象产品角色，具体产品角色

- 优点：

  优秀的扩展性

  降低代码耦合度

- 缺点：

  增加新产品时，需要增加具体的工厂类和具体的产品类，数量多时，增加了对系统理解的难度

- 跟策略模式对比：

  策略模式强调提供不同的策略方案，而工厂模式强调提供的是产品本身。

**建造者模式**：https://zhuanlan.zhihu.com/p/30032703

- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 抽象建造者角色、具体建造者角色、导演者角色、产品角色

- 优点：降低代码耦合度，优秀的扩展性

- 缺点：一定的使用范围限制，建造者模式的产品组件基本相同，若差异性较大，建造者模式不再适用。

- 跟工厂模式对比：

  都是创建产品，工厂模式就一个方法，而建造者模式多个方法，且建造者是有顺序的执行方法。

  建造者强调顺序，而工厂模式没有。

**原型模式：**https://zhuanlan.zhihu.com/p/30504050

- 用原型模式指定所有创建对象的类型，并且通过赋值这个拷贝创建新的对象。
- 必须存在一个现有的对象，即原型实例；在Java中，实现Cloneable，因为所有的类继承自Object，重写clone()方法来实现拷贝。
- 客户端角色，抽象原型角色，具体原型角色。
- 浅拷贝、深拷贝

**适配器模式：**https://yq.aliyun.com/articles/11337

**装饰模式：**https://yq.aliyun.com/articles/11338

**代理模式**

**外观模式：**https://yq.aliyun.com/articles/11340

**桥接模式：**https://yq.aliyun.com/articles/11342

**策略模式：**https://zhuanlan.zhihu.com/p/30708280

- 定义一组算法，将每一个算法封装起来，从而使他们可以互相切换。
- 封装角色、抽象策略角色、具体策略角色
- 优点：良好的扩展性，良好的封装性，避免了多重条件判断
- 缺点：客户端必须了解各个策略组的策略，并决定使用哪个策略，即策略需要暴露给客户端；策略增多，策略类数量就会增多。

**模板方法模式：**https://zhuanlan.zhihu.com/p/92277648

**解释器模式：**https://zhuanlan.zhihu.com/p/87787137



**Spring中用到的设计模式：**

- BeanFactory和ApplicationContext应用了工厂模式。
- 在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。
- AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。
- 各种事件监听器，是观察者模式的典型应用。
- 类似 JdbcTemplate 等则是应用了模板模式。



### Q15：synchronize和ReentrantLock有什么区别？

Reetrantlock是lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReetrantLock比synchronize有更加优异的性能表现。

1. 用法比较

   Lock使用起来比较灵活，但是必须有释放锁的配合动作。

   Lock必须手动获取与释放锁，而synchronize不需要手动释放和开启锁。

   Lock只适用于代码块锁，而synchronize适用于方法、代码块等。

2. 特性比较

   ReetrantLock优势体现在：

   具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一刻锁没有被其他线程获取到，则成功获取并持有锁。

   能被中断的获取锁的特性：与synchronize不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会抛出，同时锁会被释放。

   超时获取锁的特性：在指定时间范围内获取锁，如果截止时间到了仍然无法获取锁，则返回

3. 注意事项

   - 在finally中释放锁，目的是保证在获得锁后，能够释放锁
   - 不要将获取锁的过程写在try中，因为如果在获取锁时发生了异常，异常抛出的同时，会导致锁无故被释放
   - ReetrantLock提供了一个newCondition方法，以便用户在同一个锁下可以根据不同的情况执行等待或唤醒的动作。



### Q16：synchronize底层是如何实现的？什么是锁的升级、降级？

synchronize是一对monitorenter和monitorexit实现的。

Monitor对象是同步的基本实现单元。

早期（java6之前），Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。

现代JDK中，JVM对此进行了改革，提供了三种不同的Monitor实现，三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，改进了性能。

所谓锁的升级、降级，就是JVM优化synchronize运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现。

当无竞争出现时，默认使用偏斜锁。JVM利用 CAS操作，在对象头上的Mark Word部分设置线程id，以表示这个对象偏向于当前线程，所以不涉及真正的互斥锁。（这样做的假设基于，很多场景下，大部分对象生命周期最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。）

如果有另外的线程试图锁定已被偏斜过的对象，jvm就回撤销掉偏斜锁，并切换到轻量级锁实现。轻量级锁依靠CAS操作Mark Word来试图获取锁，如果重试成功，则切换到轻量级锁，否则切换到重量级锁。

锁降级：当JVM进入安全点的时候，会检查是否有限制的Monitor，然后试图进行降级。



其他锁：

![Java核心类库锁](/Users/yangzanjie/code/study/java面试整理/Java核心类库锁.png)



### Q17: 一个线程调用两次start方法会出现什么情况？谈谈线程的生命周期和状态转移。

Java线程不允许启动两次，第二次调用必然出现IllegalThreadStateException，一种运行时异常，多次调用被认为是编程错误。

**线程生命周期：**

- 新建new，表示线程被创建出来还未被真正启动的状态，可以认为是个Java内部状态。
- 就绪runnable，表示线程已经在JVM中执行，当然由于执行需要计算资源，因此可能是正在运行，等待系统分配给它cpu片段，在就绪队列里面排队。
- running
- 阻塞blocked，阻塞表示线程在等待monitor lock。
- 等待waiting，表示正等待其他线程采取某些操作。一个常见的场景，生产者-消费者模式，发现任务条件尚未满足，就让消费者线程wait，另外的生产者线程去做任务，然后通过类似notify等操作，通知消费者线程继续。Thread.join()也会令线程处于wait。
- 计时等待TIME_WAITED，进入条件和等待类似，但是调用的是存在超时条件的方法，比如wait和join的指定超时条件版本。
- 终止TERMINATED，无论是意外退出还是正常执行结束，线程已经完成使命，终止运行。

第二次调用start方法，无论线程处于终止还是其他非new状态，都是不可以再次启动的。



**线程基础**：

线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务真正的执行者，有自己的栈stack、寄存器register、本地存储ThreadLocal等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。

具体实现中，分为内核线程、用户线程，java线程的实现与虚拟机相关。

后续JDk，抛弃了Green Thread（jvm中的线程，不依赖底层操作系统的功能，管理调度发生在用户空间），现在的模型是一对一映射到操作系统内核线程。



**Java线程的基本操作**：

- 继承Thread类
- 实现Runnable接口
- Executors等框架（Java并发库），阿里不建议直接通过该框架，建议手动通过ThreadPoolExecutor创建。



**影响线程状态的因素：**

- 线程自身的方法，start、join（等待线程结束）、yield（主动告诉调度器，让出CPU）、一些已经被标记为过时的 resume、stop、suspend 之类等
- 基类Object提供的一些基础的wait/notify/notifyAll方法。如果持有某个对象的Monitor锁，调用wait会让当前线程处于等待状态，直到其他线程notify或者notiftyAll。本质是提供Monitor的获取和释放的能力，是基本的线程间通信方式。
- 并发类库中的工具类，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被基数为 0，这可以看作是线程间通信的 Signal。（还有信号量Semaphore等）

![Java线程生命周期](/Users/yangzanjie/code/study/java面试整理/Java线程生命周期.png)

Thread和Object的方法，实际用起来十分晦涩、易错，因此后来引入了并发包，有了并发包之后，大多数情况下不需要调用wait/notify方法。



**线程api的使用**

- 守护线程Daemon Thread，有时候应用中需要一个长期驻留的服务程序，但不希望其影响应用退出，就可以将其设置为守护线程。如果JVM发现只有守护线程存在时，将结束进程。**必须在线程启动前设置。**

- Spurious wakeup虚假唤醒，在多核CPU系统中，线程等待存在一种可能，就是在没有任何线程广播或发出信号的情况下，线程就被唤醒，如果处理不当，会发生诡异的问题。

  ```java
  // 推荐
  while ( isCondition()) {
  waitForAConfition(...);
  }
  
  // 不推荐，可能引入bug
  if ( isCondition()) {
  waitForAConfition(...);
  }
  ```

- 慎用ThreadLocal，这是Java提供的一种保存线程私有信息的机制，在其整个生命周期内有效，可以方便的在一个线程关联的不同业务之间传递信息，比如事务ID、Cookie等上下文相关信息。

  内部条目是弱引用，weakreference。略。

  废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应 ThreadLocalMap。

  这是很多oom的来源。



### Q18: 什么情况下Java会发生死锁？如何定位、修复？

![线程死锁](/Users/yangzanjie/code/study/java面试整理/线程死锁.png)

指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞状态。

定位死锁常用：jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。类似JConsole甚至可以在图形界面进行有限的死锁检测。



区分线程状态 -> 查看等待目标 -> 对比 Monitor 等持有状态

如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，ThreadMXBean，其直接就提供了 findDeadlockedThreads() 方法用于定位。



**如何在编程中尽量预防出现死锁？**

死锁发生的原因：

- 互斥条件
- 互斥条件是长期持有的
- 循环依赖关系

1. 尽量避免使用多个锁，只有在需要时才持有锁，
2. 如果必须持有多个锁，尽量设计好锁的获取顺序，可以用图形化的方式表示对象与锁的关系、时序
3. 使用带超时的方法，类似 Object.wait(…) 或者 CountDownLatch.await(…)，都支持所谓的 timed_wait，指定超时时间，为无法获得锁时准备推出逻辑。
4. 通过静态代码分析，如FindBugs去查找固定的模式，进而定位可能的死锁或者竞争情况。





