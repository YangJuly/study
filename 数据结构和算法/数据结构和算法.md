# 数据结构和算法

业务开发工程师，CRUD（增删改查） boy 😭😭😭

<u>目标</u>：不能重复地堆砌业务逻辑，要有难度递进，提升能力，写出达到开源水平的框架。

数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。

数据结构是为算法服务的，算法是要作用再特定的数据结构上的。

效率和资源消耗的度量衡--复杂度分析。

<u>总览</u>：

![](/Users/yangzanjie/code/study/数据结构和算法/数据结构和算法.jpg)

------



## 1 常用数据结构和算法

<u>10个数据结构</u>：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。

<u>10个算法</u>：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

<u>学习技巧</u>：

- 边学边练，适度刷题：建议每周1-2小时时间，自己实现数据结构和算法，刷题适度。
- 多问、多思考、多互动。
- 坚持：打怪升级学习法，设立切实可行的目标，一点点提高。
- 耐心：学习知识，反复迭代，不断沉淀。

------



## 2 复杂度分析

### 2.1 事后统计法

指通过统计、监控等方式，得到算法执行的时间和占用的你内存大小。

局限性大。

- 测试结果非常依赖测试环境。
- 测试结果受数据规模的影响很大。

### 2.2 大O复杂度表示法

#### 2.2.1 概念

算法执行效率，即代码执行时间（粗略讲）。

`T(n)=O(f(n))`

T(n)表示代码执行的时间；n表示数据的规模大小；f(n)表示每行代码执行的次数总和；O表示代码的执行时间T(n)与f(n)成正比。

<u>大O时间复杂度表示法，并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，故也叫作渐进时间复杂度，简称时间复杂度。</u>

n很大时，公式中的高阶项成为主导，因此只记录最大一个量级。

例如：T(n)=O(n)、T(n)=O(n^2)

#### 2.2.2 时间复杂度分析

- 只关注循环执行次数最多的一段代码

```c++
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

在这里，只关注第4、5行代码，时间复杂度O(n)。

- 加法法则，总复杂度等于量级最大的那段代码的复杂度

```c++
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

sum_1与规模无关，sum_2为O(n)，sum_3为O(n^2)，因此为O(n^2)。

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；

那么T(n)=T1(n)+T2(n)=max(O(f(n))，O(g(n))) =O(max(f(n), g(n))).

- 乘法法则，嵌套代码复杂度等于嵌套内外代码复杂度的乘积

这个好理解，略。

#### 2.2.3 常见时间复杂度案例分析

![](/Users/yangzanjie/code/study/数据结构和算法/复杂度量级.jpg)

多项式量级

非多项式量级：只有俩，O(2^n)和O(n!)

- O(1)

  一般代码，只要不存在循环、递归语句，即使有成千上万行，时间复杂度都是O(1)。

- O(log n)、O(n log n)

  对数阶复杂度。

  ```c++
   i=1;
   while (i <= n)  {
     i = i * 2;
   }
  ```

  变量i值从1开始取，每循环一次乘以2。当大于n时，循环结束，变量i的取值是一个等比数列。一个个列出来，就是2^0、2^1、2^2、2^3、、、2^k、、、、2^x  =  n。求解x=log2n，因此复杂度为O(log2n)。

  变化下

  ```c++
   i=1;
   while (i <= n)  {
     i = i * 3;
   }
  ```

  时间复杂度为O(log3n)。

  因为对数间可以相互转换，log3n=log32 ·log2n，因此log3n=log32 · log2n，log32为常量，基于前面的理论O(Cf(n)) = O(f(n))，可以忽略系数，因次此最终为O(log2n)。

  至于nlogn，即对logn的算法循环执行n遍。

- O(m+n)、O(m*n)

  代码的复杂度由两个数据的规模决定。

  ```c++
  int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++i) {
      sum_1 = sum_1 + i;
    }
  
    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
      sum_2 = sum_2 + j;
    }
  
    return sum_1 + sum_2;
  }
  ```

  m和n是表示两个数据规模，因为无法事先评估m和n的量级大小，因此不能简单的用加法法则，忽略掉其中一个，所以代码复杂度就是O(m+n)。

  针对这种情况，加法法则变为，T1(m) + T2(n) = O(f(m) + g(n))；

  但是，乘法法则依然有效，T1(m)*T2(n) = O(f(m) * f(n))。

#### 2.2.4 空间复杂度分析

渐进空间复杂度，表示算法的存储空间和数据规模之间的关系。

```c++
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

在第2行申请了一个空间存储变量i，常量阶，跟n没有关系，不考虑。

在第3行申请了一个大小为n的int类型数组，除此之外，没有别的了，因此空间复杂度O(n)。

#### 2.2.5 小结

常见复杂度，从低到高：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)。

![](/Users/yangzanjie/code/study/数据结构和算法/常见复杂度.jpg)

#### 2.2.6 Think

- 复杂度分析，提供了一个很好的理论分析方法，无关于宿主机平台，提供了对效率的一个大致的认识。
- 针对不同的宿主机平台，不同的数据集大小，同时需要进行性能测试。
- 需要具有时间和空间分析的思维，为特定应用场景选用适合的算法。

------

